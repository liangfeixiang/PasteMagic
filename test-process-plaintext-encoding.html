<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EncodingUtils.processPlaintextEncoding 测试</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 20px auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .test-container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        .test-section {
            margin-bottom: 30px;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }
        h1, h2, h3 {
            color: #333;
        }
        h1 {
            text-align: center;
            color: #2c3e50;
            border-bottom: 2px solid #3498db;
            padding-bottom: 10px;
        }
        .input-group {
            margin: 10px 0;
        }
        label {
            display: inline-block;
            width: 120px;
            font-weight: bold;
        }
        input, select {
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            width: 200px;
        }
        button {
            background-color: #3498db;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover {
            background-color: #2980b9;
        }
        .result {
            margin-top: 15px;
            padding: 10px;
            background-color: #ecf0f1;
            border-radius: 4px;
            white-space: pre-wrap;
            word-break: break-all;
        }
        .success {
            background-color: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
        }
        .error {
            background-color: #f8d7da;
            border: 1px solid #f5c6cb;
            color: #721c24;
        }
        .info {
            background-color: #d1ecf1;
            border: 1px solid #bee5eb;
            color: #0c5460;
        }
    </style>
</head>
<body>
    <h1>EncodingUtils.processPlaintextEncoding 测试</h1>
    
    <div class="test-container">
        <h2>功能说明</h2>
        <p>测试 EncodingUtils 类中的 processPlaintextEncoding 和 processPlaintextDecoding 方法。</p>
        <p><strong>处理逻辑：</strong></p>
        <ul>
            <li><strong>processPlaintextEncoding</strong>: 加密时使用，将明文按指定编码方式预处理为UTF8格式</li>
            <li><strong>processPlaintextDecoding</strong>: 解密后使用，将UTF8明文按指定编码方式后处理为目标格式</li>
        </ul>
    </div>

    <div class="test-container">
        <h2>方法测试</h2>
        <div class="test-section">
            <h3>processPlaintextEncoding 测试</h3>
            <div class="input-group">
                <label>原始明文:</label>
                <input type="text" id="plaintext" value="Hello World! 你好世界！" placeholder="输入明文">
            </div>
            <div class="input-group">
                <label>编码方式:</label>
                <select id="encodingType">
                    <option value="UTF8">UTF-8</option>
                    <option value="BASE64">Base64</option>
                    <option value="HEX">Hex</option>
                </select>
                <button onclick="testProcessEncoding()">测试编码处理</button>
            </div>
            
            <div id="encodingResult" class="result" style="display:none;"></div>
        </div>
        
        <div class="test-section">
            <h3>processPlaintextDecoding 测试</h3>
            <div class="input-group">
                <label>UTF8明文:</label>
                <input type="text" id="utf8Text" value="Hello World! 你好世界！" placeholder="输入UTF8格式明文">
            </div>
            <div class="input-group">
                <label>目标编码:</label>
                <select id="targetEncoding">
                    <option value="UTF8">UTF-8</option>
                    <option value="BASE64">Base64</option>
                    <option value="HEX">Hex</option>
                </select>
                <button onclick="testProcessDecoding()">测试解码处理</button>
            </div>
            
            <div id="decodingResult" class="result" style="display:none;"></div>
        </div>
    </div>

    <div class="test-container">
        <h2>完整流程测试</h2>
        <div class="test-section">
            <h3>加密解密完整流程</h3>
            <button onclick="testFullProcess()">测试完整流程</button>
            <div id="fullProcessResult" class="result" style="display:none;"></div>
        </div>
    </div>

    <script>
        // 模拟 CryptoJS 功能
        const CryptoJS = {
            enc: {
                Utf8: {
                    parse: (str) => ({
                        toString: (encoder) => encoder.stringify({ words: [], sigBytes: str.length }),
                        words: [],
                        sigBytes: str.length
                    }),
                    stringify: (wordArray) => {
                        // 简化实现
                        return typeof wordArray === 'string' ? wordArray : '';
                    }
                },
                Base64: {
                    parse: (str) => ({
                        toString: () => str
                    }),
                    stringify: (wordArray) => {
                        if (typeof wordArray === 'string') return wordArray;
                        // 简化的Base64编码
                        try {
                            return btoa(unescape(encodeURIComponent('test')));
                        } catch (e) {
                            return 'dGVzdA==';
                        }
                    }
                },
                Hex: {
                    parse: (str) => ({
                        toString: () => str
                    }),
                    stringify: (wordArray) => {
                        if (typeof wordArray === 'string') return wordArray;
                        // 简化的Hex编码
                        return Array.from(new TextEncoder().encode('test'))
                            .map(b => b.toString(16).padStart(2, '0'))
                            .join('');
                    }
                }
            }
        };

        // EncodingUtils 类实现
        class EncodingUtils {
            static encode(data, encodings = ['UTF8']) {
                let result = data;
                
                // 确保输入是WordArray格式
                if (typeof result === 'string') {
                    result = CryptoJS.enc.Utf8.parse(result);
                }
                
                // 从内到外应用编码（逆序处理）
                for (let i = encodings.length - 1; i >= 0; i--) {
                    const encoding = encodings[i].toUpperCase();
                    switch (encoding) {
                        case 'UTF8':
                            break;
                        case 'HEX':
                            result = result.toString(CryptoJS.enc.Hex);
                            result = CryptoJS.enc.Hex.parse(result);
                            break;
                        case 'BASE64':
                            result = result.toString(CryptoJS.enc.Base64);
                            result = CryptoJS.enc.Base64.parse(result);
                            break;
                        default:
                            break;
                    }
                }
                
                // 最终转换为字符串
                if (result && typeof result !== 'string') {
                    try {
                        result = CryptoJS.enc.Utf8.stringify(result);
                    } catch (e) {
                        result = result.toString(CryptoJS.enc.Base64);
                    }
                }
                
                return result;
            }

            static decode(data, encodings = ['UTF8']) {
                let result = data;
                
                // 按照编码顺序进行解码
                for (const encoding of encodings) {
                    const upperEncoding = encoding.toUpperCase();
                    switch (upperEncoding) {
                        case 'UTF8':
                            if (typeof result !== 'string') {
                                result = CryptoJS.enc.Utf8.stringify(result);
                            }
                            break;
                        case 'HEX':
                            if (typeof result === 'string') {
                                result = CryptoJS.enc.Hex.parse(result);
                            }
                            break;
                        case 'BASE64':
                            if (typeof result === 'string') {
                                result = CryptoJS.enc.Base64.parse(result);
                            }
                            break;
                        default:
                            break;
                    }
                }
                
                // 最终转换为UTF-8字符串
                if (result && typeof result !== 'string') {
                    try {
                        result = CryptoJS.enc.Utf8.stringify(result);
                    } catch (e) {
                        result = result.toString(CryptoJS.enc.Base64);
                    }
                }
                
                return result;
            }

            static processPlaintextEncoding(plaintext, plainEncoding = ['UTF8']) {
                // 明文编码方式处理：如果指定了非UTF8的编码方式，需要先解码
                let processedPlaintext = plaintext;
                
                if (plainEncoding && plainEncoding.length > 0 && !plainEncoding.includes('UTF8')) {
                    // 如果明文是以其他编码方式存储的，需要先解码为UTF8
                    processedPlaintext = this.decode(plaintext, plainEncoding);
                }
                
                return processedPlaintext;
            }

            static processPlaintextDecoding(plaintext, plainEncoding = ['UTF8']) {
                // 明文解码处理：如果需要输出为非UTF8格式，需要重新编码
                let processedPlaintext = plaintext;
                
                if (plainEncoding && plainEncoding.length > 0 && !plainEncoding.includes('UTF8')) {
                    // 如果需要输出为其他编码格式，需要重新编码
                    processedPlaintext = this.encode(plaintext, plainEncoding);
                }
                
                return processedPlaintext;
            }
        }

        // 测试 processPlaintextEncoding 方法
        function testProcessEncoding() {
            const plaintext = document.getElementById('plaintext').value;
            const encodingType = document.getElementById('encodingType').value;
            
            try {
                const encodingArray = [encodingType];
                const result = EncodingUtils.processPlaintextEncoding(plaintext, encodingArray);
                
                showResult('encodingResult', 
                    `原始明文: ${plaintext}\n` +
                    `编码方式: ${encodingType}\n` +
                    `处理结果: ${result}\n` +
                    `处理说明: ${encodingType === 'UTF8' ? '保持原样（UTF8是默认格式）' : '已解码为UTF8格式'}`, 
                    'success');
                    
            } catch (error) {
                showResult('encodingResult', `处理失败: ${error.message}`, 'error');
            }
        }

        // 测试 processPlaintextDecoding 方法
        function testProcessDecoding() {
            const utf8Text = document.getElementById('utf8Text').value;
            const targetEncoding = document.getElementById('targetEncoding').value;
            
            try {
                const encodingArray = [targetEncoding];
                const result = EncodingUtils.processPlaintextDecoding(utf8Text, encodingArray);
                
                showResult('decodingResult', 
                    `UTF8明文: ${utf8Text}\n` +
                    `目标编码: ${targetEncoding}\n` +
                    `处理结果: ${result}\n` +
                    `处理说明: ${targetEncoding === 'UTF8' ? '保持原样（UTF8是默认格式）' : '已编码为目标格式'}`, 
                    'success');
                    
            } catch (error) {
                showResult('decodingResult', `处理失败: ${error.message}`, 'error');
            }
        }

        // 测试完整流程
        function testFullProcess() {
            const originalText = "Hello World! 你好世界！";
            const testEncodings = ['UTF8', 'BASE64', 'HEX'];
            
            let results = [`原始文本: ${originalText}\n`];
            
            testEncodings.forEach(encoding => {
                try {
                    const encodingArray = [encoding];
                    
                    // 模拟加密流程：编码处理 → 加密 → 解密 → 解码处理
                    const processedForEncryption = EncodingUtils.processPlaintextEncoding(originalText, encodingArray);
                    // 这里模拟加密解密过程
                    const decryptedText = processedForEncryption; // 简化处理
                    const finalResult = EncodingUtils.processPlaintextDecoding(decryptedText, encodingArray);
                    
                    const isSuccess = finalResult === originalText;
                    results.push(
                        `${encoding} 编码测试:\n` +
                        `  加密前处理: ${processedForEncryption}\n` +
                        `  解密后处理: ${finalResult}\n` +
                        `  一致性验证: ${isSuccess ? '✓ 通过' : '✗ 失败'}\n`
                    );
                } catch (error) {
                    results.push(`${encoding} 编码测试: ✗ 错误 - ${error.message}\n`);
                }
            });
            
            showResult('fullProcessResult', results.join('\n'), 'info');
        }

        // 显示结果
        function showResult(elementId, message, type) {
            const element = document.getElementById(elementId);
            element.textContent = message;
            element.className = `result ${type}`;
            element.style.display = 'block';
        }
    </script>
</body>
</html>