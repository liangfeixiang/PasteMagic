<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CTRæ¨¡å¼ä¿®å¤éªŒè¯æµ‹è¯•</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background: white;
            border-radius: 8px;
            padding: 24px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .test-section {
            margin-bottom: 30px;
            padding: 20px;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            background-color: #fafafa;
        }
        .result-card {
            margin: 15px 0;
            padding: 15px;
            border-radius: 6px;
            font-family: monospace;
            font-size: 14px;
        }
        .success { background-color: #d4edda; border-left: 4px solid #28a745; }
        .error { background-color: #f8d7da; border-left: 4px solid #dc3545; }
        .warning { background-color: #fff3cd; border-left: 4px solid #ffc107; }
        .info { background-color: #d1ecf1; border-left: 4px solid #17a2b8; }
        textarea, input { 
            width: 100%; 
            padding: 10px; 
            margin: 8px 0; 
            border: 1px solid #ddd; 
            border-radius: 4px; 
            font-family: monospace;
        }
        button {
            padding: 10px 20px;
            margin: 5px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 500;
        }
        button:hover { background: #0056b3; }
        .mode-selector {
            display: flex;
            gap: 10px;
            margin: 15px 0;
            flex-wrap: wrap;
        }
        .mode-btn {
            padding: 8px 16px;
            background: #6c757d;
            color: white;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-size: 14px;
        }
        .mode-btn.active { background: #007bff; }
        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
        }
        .comparison-table th, .comparison-table td {
            border: 1px solid #ddd;
            padding: 10px;
            text-align: left;
        }
        .comparison-table th {
            background-color: #f8f9fa;
            font-weight: 600;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ”§ CTRæ¨¡å¼è§£å¯†ä¿®å¤éªŒè¯</h1>
        <p>æµ‹è¯•ä¿®å¤åçš„CTRæ¨¡å¼è§£å¯†åŠŸèƒ½ï¼ŒéªŒè¯æ˜¯å¦è§£å†³äº†å¤šä½™ç©ºæ ¼é—®é¢˜</p>
        
        <div class="test-section">
            <h3>ğŸ“Š å¿«é€Ÿæµ‹è¯•å¥—ä»¶</h3>
            <div class="mode-selector">
                <button class="mode-btn active" onclick="setMode('CTR')">CTRæ¨¡å¼</button>
                <button class="mode-btn" onclick="setMode('CBC')">CBCæ¨¡å¼</button>
                <button class="mode-btn" onclick="setMode('CFB')">CFBæ¨¡å¼</button>
            </div>
            
            <textarea id="testInput" placeholder="è¾“å…¥æµ‹è¯•æ–‡æœ¬...">Hello World! è¿™æ˜¯æµ‹è¯•æ¶ˆæ¯ã€‚</textarea>
            
            <div>
                <button onclick="runSingleTest()">è¿è¡Œå•æ¬¡æµ‹è¯•</button>
                <button onclick="runComprehensiveTest()">è¿è¡Œç»¼åˆæµ‹è¯•</button>
                <button onclick="runEdgeCaseTest()">è¿è¡Œè¾¹ç•Œæƒ…å†µæµ‹è¯•</button>
                <button onclick="clearResults()">æ¸…ç©ºç»“æœ</button>
            </div>
            
            <div id="testResults"></div>
        </div>
        
        <div class="test-section">
            <h3>ğŸ“‹ è¯¦ç»†å¯¹æ¯”æµ‹è¯•</h3>
            <div>
                <label>æµ‹è¯•æ–‡æœ¬ï¼ˆæ¯è¡Œä¸€ä¸ªï¼‰:</label>
                <textarea id="multiLineInput" rows="6">Hello
Hello World!
Hello World! æµ‹è¯•
è¿™æ˜¯ä¸€ä¸ªä¸­æ–‡æµ‹è¯•æ¶ˆæ¯
Mixed content: ä¸­è‹±æ–‡æ··åˆæµ‹è¯•
Short
Very long text that exceeds typical block sizes and might cause padding issues in various encryption modes</textarea>
            </div>
            <button onclick="runMultiLineTest()">è¿è¡Œå¤šè¡Œå¯¹æ¯”æµ‹è¯•</button>
            <div id="multiLineResults"></div>
        </div>
    </div>

    <script>
        let currentMode = 'CTR';
        
        // å›ºå®šçš„å¯†é’¥å’ŒIVé…ç½®
        const TEST_CONFIG = {
            key: { value: '1234567890123456', encoding: ['UTF8'] },
            iv: { value: 'abcdefghijklmnop', encoding: ['UTF8'] },
            mode: 'CTR',
            padding: 'NoPadding'
        };
        
        // æ¨¡æ‹Ÿä¿®å¤åçš„CipherUtils.decryptæ–¹æ³•
        function fixedDecrypt(ciphertext, config) {
            const { key, iv, mode = 'CBC', padding = 'Pkcs7' } = config;
            
            // å¤„ç†å¯†é’¥
            let parsedKey = key.value;
            if (key.encoding && key.encoding.length > 0) {
                parsedKey = EncodingUtils.decode(key.value, key.encoding);
            }
            
            // å¤„ç†åˆå§‹åŒ–å‘é‡
            let parsedIv = iv?.value || '';
            if (iv?.encoding && iv.encoding.length > 0) {
                parsedIv = EncodingUtils.decode(iv.value, iv.encoding);
            }
            
            const keyWordArray = CryptoJS.enc.Utf8.parse(parsedKey);
            const ivWordArray = CryptoJS.enc.Utf8.parse(parsedIv);
            
            // å¤„ç†æ¨¡å¼å’Œå¡«å……æ–¹å¼
            const modeUpper = mode.toUpperCase();
            const paddingUpper = padding.toUpperCase().replace('PADDING', '');
            
            const cryptoMode = CryptoJS.mode[modeUpper] || CryptoJS.mode.CBC;
            const cryptoPadding = CryptoJS.pad[paddingUpper] || CryptoJS.pad.Pkcs7;
            
            // CFB, OFB, CTR æ¨¡å¼é€šå¸¸ä¸ä½¿ç”¨å¡«å……
            const usePadding = ['ECB', 'CBC'].includes(modeUpper);
            
            const decryptOptions = {
                mode: cryptoMode,
                padding: usePadding ? cryptoPadding : CryptoJS.pad.NoPadding
            };
            
            // åªæœ‰éœ€è¦IVçš„æ¨¡å¼æ‰æ·»åŠ ivå‚æ•°
            if (['CBC', 'CFB', 'OFB', 'CTR'].includes(modeUpper)) {
                decryptOptions.iv = ivWordArray;
            }
            
            const decrypted = CryptoJS.AES.decrypt(ciphertext, keyWordArray, decryptOptions);
            
            // é’ˆå¯¹CTRæ¨¡å¼çš„ç‰¹æ®Šå¤„ç†ï¼šæ‰‹åŠ¨ç§»é™¤å¯èƒ½çš„é›¶å¡«å……
            if (modeUpper === 'CTR') {
                // è·å–åŸå§‹å­—èŠ‚æ•°ç»„
                const words = decrypted.words;
                const sigBytes = decrypted.sigBytes;
                
                // è½¬æ¢ä¸ºUint8Array
                const bytes = new Uint8Array(sigBytes);
                for (let i = 0; i < sigBytes; i++) {
                    const wordIndex = Math.floor(i / 4);
                    const byteIndex = i % 4;
                    bytes[i] = (words[wordIndex] >>> (24 - byteIndex * 8)) & 0xff;
                }
                
                // æŸ¥æ‰¾å¹¶ç§»é™¤æœ«å°¾çš„é›¶å­—èŠ‚å¡«å……
                let actualLength = sigBytes;
                for (let i = sigBytes - 1; i >= 0; i--) {
                    if (bytes[i] === 0) {
                        actualLength = i;
                    } else {
                        break;
                    }
                }
                
                // åªå–æœ‰æ•ˆéƒ¨åˆ†è½¬æ¢ä¸ºå­—ç¬¦ä¸²
                const validBytes = bytes.slice(0, actualLength);
                return new TextDecoder().decode(validBytes);
            }
            
            return decrypted.toString(CryptoJS.enc.Utf8);
        }
        
        // ç®€åŒ–çš„ç¼–ç å·¥å…·ç±»
        const EncodingUtils = {
            decode: (value, encoding) => {
                if (encoding.includes('HEX')) {
                    return CryptoJS.enc.Hex.parse(value).toString(CryptoJS.enc.Utf8);
                }
                return value;
            }
        };
        
        // åŠ å¯†å‡½æ•°
        function encryptText(text, mode = 'CTR') {
            const config = {...TEST_CONFIG, mode: mode};
            const { key, iv } = config;
            
            let parsedKey = key.value;
            if (key.encoding && key.encoding.length > 0) {
                parsedKey = EncodingUtils.decode(key.value, key.encoding);
            }
            
            let parsedIv = iv?.value || '';
            if (iv?.encoding && iv.encoding.length > 0) {
                parsedIv = EncodingUtils.decode(iv.value, iv.encoding);
            }
            
            const keyWordArray = CryptoJS.enc.Utf8.parse(parsedKey);
            const ivWordArray = CryptoJS.enc.Utf8.parse(parsedIv);
            
            const modeUpper = mode.toUpperCase();
            const cryptoMode = CryptoJS.mode[modeUpper] || CryptoJS.mode.CTR;
            const usePadding = ['ECB', 'CBC'].includes(modeUpper);
            
            const encryptOptions = {
                mode: cryptoMode,
                padding: usePadding ? CryptoJS.pad.Pkcs7 : CryptoJS.pad.NoPadding
            };
            
            if (['CBC', 'CFB', 'OFB', 'CTR'].includes(modeUpper)) {
                encryptOptions.iv = ivWordArray;
            }
            
            return CryptoJS.AES.encrypt(text, keyWordArray, encryptOptions).toString();
        }
        
        function setMode(mode) {
            currentMode = mode;
            // æ›´æ–°æŒ‰é’®çŠ¶æ€
            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            TEST_CONFIG.mode = mode;
        }
        
        function runSingleTest() {
            const inputText = document.getElementById('testInput').value.trim();
            const resultsDiv = document.getElementById('testResults');
            
            if (!inputText) {
                resultsDiv.innerHTML = '<div class="result-card error">è¯·è¾“å…¥æµ‹è¯•æ–‡æœ¬</div>';
                return;
            }
            
            try {
                const ciphertext = encryptText(inputText, currentMode);
                const decrypted = fixedDecrypt(ciphertext, TEST_CONFIG);
                
                const isSuccess = decrypted === inputText;
                const resultClass = isSuccess ? 'success' : 'error';
                
                const resultHtml = `
                    <div class="result-card ${resultClass}">
                        <h4>ğŸ¯ å•æ¬¡æµ‹è¯•ç»“æœ (${currentMode}æ¨¡å¼)</h4>
                        <div><strong>åŸæ–‡:</strong> "${inputText}"</div>
                        <div><strong>é•¿åº¦:</strong> ${inputText.length} å­—ç¬¦</div>
                        <div><strong>è§£å¯†ç»“æœ:</strong> "${decrypted}"</div>
                        <div><strong>é•¿åº¦:</strong> ${decrypted.length} å­—ç¬¦</div>
                        <div><strong>ä¸¥æ ¼åŒ¹é…:</strong> ${isSuccess ? 'âœ… æˆåŠŸ' : 'âŒ å¤±è´¥'}</div>
                        ${!isSuccess ? `<div><strong>å·®å¼‚åˆ†æ:</strong> ${analyzeDifference(inputText, decrypted)}</div>` : ''}
                    </div>
                `;
                
                resultsDiv.innerHTML = resultHtml;
            } catch (error) {
                resultsDiv.innerHTML = `<div class="result-card error"><strong>âŒ é”™è¯¯:</strong> ${error.message}</div>`;
            }
        }
        
        function runComprehensiveTest() {
            const testCases = [
                'A',
                'AB',
                'ABC',
                'Hello',
                'Hello World!',
                'Hello World! æµ‹è¯•',
                'è¿™æ˜¯ä¸€ä¸ªä¸­æ–‡æµ‹è¯•',
                'Mixed: ä¸­è‹±æ–‡123',
                'Special chars: !@#$%^&*()',
                'Line1\nLine2\nLine3',
                'Very long text that might cause block alignment issues in CTR mode decryption process'
            ];
            
            const resultsDiv = document.getElementById('testResults');
            let resultsHtml = '<h4>ğŸ“‹ ç»¼åˆæµ‹è¯•ç»“æœ</h4>';
            
            let passed = 0;
            let failed = 0;
            
            testCases.forEach((text, index) => {
                try {
                    const ciphertext = encryptText(text, currentMode);
                    const decrypted = fixedDecrypt(ciphertext, TEST_CONFIG);
                    const isSuccess = decrypted === text;
                    
                    if (isSuccess) {
                        passed++;
                        resultsHtml += `<div class="result-card success">âœ… æµ‹è¯•${index + 1}: "${text}" (é•¿åº¦:${text.length})</div>`;
                    } else {
                        failed++;
                        resultsHtml += `<div class="result-card error">âŒ æµ‹è¯•${index + 1}: "${text}"<br>
                                       &nbsp;&nbsp;&nbsp;åŸæ–‡é•¿åº¦:${text.length} vs è§£å¯†é•¿åº¦:${decrypted.length}<br>
                                       &nbsp;&nbsp;&nbsp;å·®å¼‚: ${analyzeDifference(text, decrypted)}</div>`;
                    }
                } catch (error) {
                    failed++;
                    resultsHtml += `<div class="result-card error">âŒ æµ‹è¯•${index + 1}: "${text}" - é”™è¯¯: ${error.message}</div>`;
                }
            });
            
            resultsHtml += `<div class="result-card info"><strong>æ€»ç»“:</strong> é€šè¿‡ ${passed}/${testCases.length} ä¸ªæµ‹è¯• (${Math.round((passed/testCases.length)*100)}%)</div>`;
            
            resultsDiv.innerHTML = resultsHtml;
        }
        
        function runEdgeCaseTest() {
            const edgeCases = [
                '',  // ç©ºå­—ç¬¦ä¸²
                ' ', // å•ä¸ªç©ºæ ¼
                '  ', // å¤šä¸ªç©ºæ ¼
                '\u0000', // ç©ºå­—ç¬¦
                'a\u0000b', // åŒ…å«ç©ºå­—ç¬¦
                'ä¸­æ–‡\u0000æµ‹è¯•', // ä¸­æ–‡+ç©ºå­—ç¬¦
                String.fromCharCode(0, 1, 2, 3), // æ§åˆ¶å­—ç¬¦
                'Normal text' + String.fromCharCode(0, 0, 0), // æœ«å°¾é›¶å­—ç¬¦
            ];
            
            const resultsDiv = document.getElementById('testResults');
            let resultsHtml = '<h4>âš ï¸ è¾¹ç•Œæƒ…å†µæµ‹è¯•</h4>';
            
            edgeCases.forEach((text, index) => {
                try {
                    const ciphertext = encryptText(text, currentMode);
                    const decrypted = fixedDecrypt(ciphertext, TEST_CONFIG);
                    const isSuccess = decrypted === text;
                    
                    const displayText = text.replace(/\0/g, '\\0').replace(/\s/g, s => s === ' ' ? 'â£' : s);
                    const displayDecrypted = decrypted.replace(/\0/g, '\\0').replace(/\s/g, s => s === ' ' ? 'â£' : s);
                    
                    resultsHtml += `<div class="result-card ${isSuccess ? 'success' : 'warning'}">
                                   ${isSuccess ? 'âœ…' : 'âš ï¸'} è¾¹ç•Œæµ‹è¯•${index + 1}: "${displayText}"<br>
                                   &nbsp;&nbsp;&nbsp;è§£å¯†: "${displayDecrypted}"<br>
                                   &nbsp;&nbsp;&nbsp;åŒ¹é…: ${isSuccess ? 'æ˜¯' : 'å¦'}</div>`;
                } catch (error) {
                    resultsHtml += `<div class="result-card error">âŒ è¾¹ç•Œæµ‹è¯•${index + 1}: é”™è¯¯ - ${error.message}</div>`;
                }
            });
            
            resultsDiv.innerHTML = resultsHtml;
        }
        
        function runMultiLineTest() {
            const inputText = document.getElementById('multiLineInput').value;
            const testLines = inputText.split('\n').filter(line => line.trim());
            const resultsDiv = document.getElementById('multiLineResults');
            
            if (testLines.length === 0) {
                resultsDiv.innerHTML = '<div class="result-card error">è¯·è¾“å…¥è‡³å°‘ä¸€è¡Œæµ‹è¯•æ–‡æœ¬</div>';
                return;
            }
            
            let resultsHtml = '<h4>ğŸ“Š å¤šè¡Œå¯¹æ¯”æµ‹è¯•ç»“æœ</h4>';
            resultsHtml += `
                <table class="comparison-table">
                    <thead>
                        <tr>
                            <th>#</th>
                            <th>åŸæ–‡</th>
                            <th>åŸæ–‡é•¿åº¦</th>
                            <th>è§£å¯†ç»“æœ</th>
                            <th>è§£å¯†é•¿åº¦</th>
                            <th>çŠ¶æ€</th>
                            <th>å·®å¼‚</th>
                        </tr>
                    </thead>
                    <tbody>
            `;
            
            let passed = 0;
            let failed = 0;
            
            testLines.forEach((text, index) => {
                try {
                    const ciphertext = encryptText(text, currentMode);
                    const decrypted = fixedDecrypt(ciphertext, TEST_CONFIG);
                    const isSuccess = decrypted === text;
                    
                    if (isSuccess) {
                        passed++;
                    } else {
                        failed++;
                    }
                    
                    resultsHtml += `
                        <tr class="${isSuccess ? 'success' : 'error'}">
                            <td>${index + 1}</td>
                            <td>"${text}"</td>
                            <td>${text.length}</td>
                            <td>"${decrypted}"</td>
                            <td>${decrypted.length}</td>
                            <td>${isSuccess ? 'âœ…' : 'âŒ'}</td>
                            <td>${isSuccess ? '-' : analyzeDifference(text, decrypted)}</td>
                        </tr>
                    `;
                } catch (error) {
                    failed++;
                    resultsHtml += `
                        <tr class="error">
                            <td>${index + 1}</td>
                            <td>"${text}"</td>
                            <td>${text.length}</td>
                            <td colspan="3">é”™è¯¯: ${error.message}</td>
                            <td>-</td>
                        </tr>
                    `;
                }
            });
            
            resultsHtml += `
                    </tbody>
                </table>
                <div class="result-card info"><strong>æµ‹è¯•æ€»ç»“:</strong> é€šè¿‡ ${passed}/${testLines.length} ä¸ªæµ‹è¯• (${Math.round((passed/testLines.length)*100)}%)</div>
            `;
            
            resultsDiv.innerHTML = resultsHtml;
        }
        
        function analyzeDifference(str1, str2) {
            if (str1 === str2) return 'æ— å·®å¼‚';
            
            const minLength = Math.min(str1.length, str2.length);
            for (let i = 0; i < minLength; i++) {
                if (str1[i] !== str2[i]) {
                    return `ä½ç½®${i}: '${str1[i]}'(${str1.charCodeAt(i)}) vs '${str2[i]}'(${str2.charCodeAt(i)})`;
                }
            }
            
            if (str1.length !== str2.length) {
                const longer = str1.length > str2.length ? str1 : str2;
                const shorter = str1.length > str2.length ? str2 : str1;
                const diffStart = shorter.length;
                const extraChars = longer.substring(diffStart);
                return `é•¿åº¦ä¸åŒ: ${shorter.length} vs ${longer.length}, å¤šä½™å­—ç¬¦: "${extraChars}" (ASCII: [${Array.from(extraChars).map(c => c.charCodeAt(0)).join(',')}])`;
            }
            
            return 'æœªçŸ¥å·®å¼‚';
        }
        
        function clearResults() {
            document.getElementById('testResults').innerHTML = '';
            document.getElementById('multiLineResults').innerHTML = '';
        }
    </script>
</body>
</html>